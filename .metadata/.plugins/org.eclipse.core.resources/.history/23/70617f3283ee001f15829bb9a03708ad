/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "lcd.h"

#include "app_config.h"
#include "screen.h"
#include "apps.h"
/* Private typedef -----------------------------------------------------------*/
typedef struct{
	ScreenID_t sc_id;
	uint16_t key;
	uint8_t	status;	
}Screen_param_t;

typedef ScreenID_t (*screen_func_t) (Screen_param_t param);

/* Private define ------------------------------------------------------------*/
enum{
	eCH_CHSelect,
	eCH_OnTIME,
	eCH_DelayTIME,
	eCH_TriggerSet,
	eSEL_OPMODE,
	eSET_OPMODE,
	eRS_DevID,
	eIP_Set,
	ePORT_Set,
	eSelf_Test,
	eRemote_Mode,
	eUSER_Mode,
	eFactor_Mode,
	eSEL_OP_Ch,
	eVer_Disp,
	eCH_MAXStep
};

enum{
	eREMOTE_NONE,
	eREMOTE_RS232,
	eREMOTE_ETHER,
};

typedef enum{
	eCMD_OutMode=0xB1,
	eCMD_Ontime,
	eCMD_Delaytime,
	eCMD_InputCh,
	eCMD_OutCh,			// 0xB5
	eCMD_Trigger,
	eCMD_TriggerSet,
	eCMD_InputEdge,
	eCMD_Factory,		// 0xB9
	eCMD_Status,
	eCMD_CloseRemote,
	eCMD_SelfTest = 0xC1,
	eCMD_RemoteSerial,
	eCMD_RemoteEth,
}BackEnd_Cmd_t;
#define MAX_DEV_ID	10
#define LINE_CHARACTER_MAX	16
#define LCD_PRINT_MAX		20
/* Private macro -------------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/
static const char charSet[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -_";
#define CHARSET_LENGTH (sizeof(charSet) - 1)
/* Private function prototypes -----------------------------------------------*/
ScreenID_t channel_screen_func(Screen_param_t param);
ScreenID_t set_changetime_func(Screen_param_t param);
//ScreenID_t set_triggermode_func(Screen_param_t param);
//ScreenID_t operation_screen_func(Screen_param_t param);
ScreenID_t blink_text_screen_func(Screen_param_t param);
ScreenID_t uart_screen_func(Screen_param_t param);
ScreenID_t ip_screen_func(Screen_param_t param);
ScreenID_t port_screen_func(Screen_param_t param);
ScreenID_t self_test_screen_func(Screen_param_t param);
ScreenID_t remote_screen_func(Screen_param_t param);
ScreenID_t user_screen_func(Screen_param_t param);
ScreenID_t factory_screen_func(Screen_param_t param);
ScreenID_t select_ch_screen_func(Screen_param_t param);
ScreenID_t version_screen_func(Screen_param_t param);

static struct _screen_func{
	ScreenID_t 		id;
	screen_func_t func;
}screen_func_list[]={
	{eCHANNEL_SC, channel_screen_func},
	{eSET_ON_TIME_SC,set_changetime_func},
	{eSET_DELAY_TIME_SC,set_changetime_func},
	{eSET_TRIGGER_SC, blink_text_screen_func},
	{eOPMODE_SC, blink_text_screen_func},
	{eUARTMODE_SC, uart_screen_func},
	{eETH_IP_SC, ip_screen_func},
	{eETH_PORT_SC, port_screen_func},
	{eTESTMODE_SC, self_test_screen_func},
	{eREMOTE_SC, remote_screen_func},
	{eUSERMODE_SC, user_screen_func},
	{eFACTORY_SC, factory_screen_func},
	{eCHSELECT_SC, select_ch_screen_func},
	{eVERSION_SC, version_screen_func}
};
#define MAX_SC_LIST_NUM 13

static struct{
	uint8_t cur_ch;
	uint8_t cursor;
	int8_t input_num[5];
	uint8_t digit_num;
	uint16_t set_time;
	uint8_t enable_blink;
	uint8_t blink;
	char blink_text[2][LCD_PRINT_MAX];
	int8_t ipaddr[4][3];
	uint8_t ip_idx;
	uint8_t ip_digit;
	int8_t port[5];
	uint8_t set_mode;
	uint8_t remote_mode;
	char model_name[LINE_CHARACTER_MAX];
}m_cfg={
	.set_mode = 0,
	.remote_mode = eREMOTE_NONE
};
/* Private functions ---------------------------------------------------------*/
void screen_init(void)
{
	char line_buf[LCD_PRINT_MAX];

	memset(&m_cfg, 0, sizeof(m_cfg));
	memcpy(m_cfg.model_name, m_app_config->company, LINE_CHARACTER_MAX);
	sprintf(line_buf,"%s\n", m_cfg.model_name);
	LOG_DBG("Model : %s", line_buf);
	LCD_LOCATE(1,2);
	LCD_printstring(line_buf);
	LCD_LOCATE(2,1);
	LCD_printstring("StrobeController\n");
}

void screen_blink(void)
{
	if(m_cfg.enable_blink){
		LCD_LOCATE(2,1);
		if(~m_cfg.blink){			
			LCD_printstring(m_cfg.blink_text[0]);
		}else{
			LCD_printstring(m_cfg.blink_text[1]);
		}
	}
}

static void send_cmd_2_backend(BackEnd_Cmd_t cmd, uint16_t value)
{
	// Todo : Send Cmd
}

ScreenID_t screen_process(ScreenID_t screen_id, Key_t key)
{
	int menu_list_size = MAX_SC_LIST_NUM;
	int i;	
	Screen_param_t sc_param;

	LOG_INF("%s : key[%s]", screen_id_2_str(screen_id), key_id_2_str(key));
	sc_param.sc_id = screen_id;
	sc_param.key = key;
	for(i = 0; menu_list_size; i++){
		if(screen_id == screen_func_list[i].id){
			return screen_func_list[i].func(sc_param);			
		}
	}
	return eMAX_SCREEN_ID;
}

static void draw_title(uint8_t step)
{
	char line_1_buf[LCD_PRINT_MAX], line_2_buf[LCD_PRINT_MAX];

	LOG_INF("start Draw title [%d]\r\n", step);
	switch(step){
		case eCH_CHSelect:
			sprintf(line_1_buf, "CH%d   Operation\n", m_cfg.cur_ch);
			sprintf(line_2_buf, "OnTime : %5dus", m_app_config->on_time[m_cfg.cur_ch]);
			break;
		case eCH_OnTIME:
			sprintf(line_1_buf, "CH%d On-Time     \n", m_cfg.cur_ch);
			sprintf(line_2_buf, "Value : %5d us", m_app_config->on_time[m_cfg.cur_ch]);
			break;
		case eCH_DelayTIME:
			sprintf(line_1_buf, "CH%d Delay-Time  \n", m_cfg.cur_ch);
			sprintf(line_2_buf, "Value : %5d us", m_app_config->delay_time[m_cfg.cur_ch]);
			break;
		case eCH_TriggerSet:
			sprintf(line_1_buf, "CH%d Trigger Set \n", m_cfg.cur_ch);
			sprintf(line_2_buf, "Value : %s \n", m_app_config->edge[m_cfg.cur_ch]?"Rising":"Falling");
			memcpy(m_cfg.blink_text[0], line_2_buf, 17);
			sprintf(m_cfg.blink_text[1],"Value :         ");
			break;
		case eSEL_OPMODE:
			sprintf(line_1_buf, "Mode Select     \n");
			sprintf(line_2_buf, "      %s     \n", m_app_config->mode?"1 : N":"1 : 1");
			break;
		case eSET_OPMODE:
			sprintf(line_1_buf, "Mode Selection  \n");
			sprintf(line_2_buf, "      %s     ", m_app_config->mode?"1 : N":"1 : 1");
			break;
		case eRS_DevID:
			sprintf(line_1_buf, "RS232 Operation  \n");
			sprintf(line_2_buf, "Device ID : %02d", m_app_config->dev_id);
			break;
		case eIP_Set:
			sprintf(line_1_buf, "Communication  \n");
			sprintf(line_2_buf, "%03d.%03d.%03d.%03d ", m_app_config->ether.ipaddr[0], m_app_config->ether.ipaddr[1], m_app_config->ether.ipaddr[2], m_app_config->ether.ipaddr[3]);
			break;
		case ePORT_Set:
			sprintf(line_1_buf, "Communication  \n");
			sprintf(line_2_buf, "Port : %d    \n", m_app_config->ether.port);
			break;
		case eRemote_Mode:
			sprintf(line_1_buf, "Communication  \n");
			if(m_cfg.remote_mode == eREMOTE_RS232){
				sprintf(line_2_buf, "RS232...       \n");
			}else{
				sprintf(line_2_buf, "Ethernet...    \n");
			}
			break;
		case eSelf_Test:
			sprintf(line_1_buf, "Test Operation  \n");
			sprintf(line_2_buf, "Testing...      \n");
			break;
		case eUSER_Mode:
			sprintf(line_1_buf, " %s\n", m_app_config->company);
			sprintf(line_2_buf, "StrobeController\n");
			break;
		case eFactor_Mode:
			sprintf(line_1_buf, "Factory mode    \n");
			sprintf(line_2_buf, "Reset...        \n");
			break;
		case eSEL_OP_Ch:
			sprintf(line_1_buf, "CH1 CH2 CH4 CH6 \n");
			sprintf(line_2_buf, "CH8             \n");
			break;
		case eVer_Disp:
			sprintf(line_1_buf, "F - FW : Ver %1d.%1d\n", m_app_config->frontVer/10, m_app_config->frontVer%10);
			sprintf(line_2_buf, "M - FW : Ver %1d.%1d\n", m_app_config->backendVer/10, m_app_config->backendVer%10);
			break;
	}
	LCD_LOCATE(1,1);
	LCD_printstring(line_1_buf);
	LCD_LOCATE(2,1);
	LCD_printstring(line_2_buf);
	LOG_INF("End Draw title\r\n");
}

static void split_num(uint16_t value, int8_t *array)
{
	int num = value, i;

	for(i = m_cfg.digit_num; i >= 0; i--){
		array[i] = -1;  // init value
		if(num){
			array[i] = num%10;
			num/=10;
		}
	}
}

static uint16_t combine_array(int8_t *array)
{
	int i;
	uint16_t value = 0;
	
	for(i = 0; i <= m_cfg.digit_num; i++){
		if(array[i] >= 0){
			value = (value*10)+array[i];
		}
	}
	
	return value;
}

ScreenID_t channel_screen_func(Screen_param_t param)
{
	LOG_INF("Enter ch screen\r\n");
	m_cfg.cursor = 0;
	switch(param.key){
		case eKey_Idle:
			m_cfg.cur_ch = eCH1;
			break;
		case eKey_Up:
			m_cfg.cur_ch++;
			if(m_cfg.cur_ch == eCH_MAX){
				m_cfg.cur_ch = eCH1;
			}			
			break;
		case eKey_Down:
			m_cfg.cur_ch--;
			if(m_cfg.cur_ch < eCH1){
				m_cfg.cur_ch = eCH8;
			}			
			break;
		case eKey_SetMode:
			draw_title(eCH_OnTIME);
			m_cfg.set_time = m_app_config->on_time[m_cfg.cur_ch-1];
			m_cfg.cursor = 13;
			m_cfg.digit_num = 4;  // 0 ~ 4
			split_num(m_cfg.set_time, m_cfg.input_num);			
			LCD_LOCATE(2, m_cfg.cursor);
			LCD_DISP_CURSOR();
			return eSET_ON_TIME_SC;
		default:
			break;
	}
	
	draw_title(eCH_CHSelect);	
	LOG_INF("Return ch scree function\r\n");
	return eMAX_SCREEN_ID;
}

ScreenID_t set_changetime_func(Screen_param_t param)
{
	char line_1_buf[LCD_PRINT_MAX], line_2_buf[LCD_PRINT_MAX];
	ScreenID_t ret_sc = param.sc_id;
	uint8_t old_cursor = m_cfg.cursor;
	uint8_t digit_idx = (m_cfg.cursor - 9);
	uint8_t change_value = 0;
	
	switch(param.key){
		case eKey_Up:
			if(m_cfg.input_num[digit_idx]++ >= 9){
				m_cfg.input_num[digit_idx] = 0;
			}
			change_value=1;
			break;
		case eKey_Down:			
			if(m_cfg.input_num[digit_idx]-- <= 0){
				m_cfg.input_num[digit_idx] = 9;
			}
			change_value=1;
			break;
		case eKey_CursorUp:
			if(m_cfg.cursor-- <= 9){
				m_cfg.cursor = 13;
			}
			break;
		case eKey_CursorDown:
			if(m_cfg.cursor++ >= 13){
				m_cfg.cursor = 9;
			}		
			break;
		case eKey_Enter:
			if(param.sc_id == eSET_ON_TIME_SC){
				m_app_config->on_time[m_cfg.cur_ch-1] = combine_array(m_cfg.input_num);
			}else{
				m_app_config->delay_time[m_cfg.cur_ch-1] = combine_array(m_cfg.input_num);
			}			
		case eKey_Mode:
			if(param.sc_id == eSET_ON_TIME_SC){
				draw_title(eCH_DelayTIME);
				ret_sc = eSET_DELAY_TIME_SC;
				m_cfg.set_time = m_app_config->delay_time[m_cfg.cur_ch-1];
				m_cfg.cursor = 13;
				m_cfg.digit_num = 4;  // 0 ~ 4
				split_num(m_cfg.set_time, m_cfg.input_num);			
				LCD_LOCATE(2, m_cfg.cursor);
			}else{
				draw_title(eCH_TriggerSet);
				m_cfg.enable_blink = 1;
				m_cfg.blink = 0;
				ret_sc = eSET_TRIGGER_SC;
				LCD_DISP_ON(); // Cursor off
			}
			break;
	}

	if(change_value){
		LOG_DBG("Change Value Ch[%d] time[%d]", m_cfg.cur_ch, combine_array(m_cfg.input_num));
		if(param.sc_id == eSET_ON_TIME_SC){
			sprintf(line_1_buf, "CH%d On-Time     \n", m_cfg.cur_ch);
		}else{
			sprintf(line_1_buf, "CH%d Delay-Time  \n", m_cfg.cur_ch);
		}
		sprintf(line_2_buf, "Value : %05d us", combine_array(m_cfg.input_num));
		LCD_LOCATE(2,1);
		LCD_printstring(line_2_buf);
	}
	if(m_cfg.cursor != old_cursor){
		LCD_LOCATE(2, m_cfg.cursor);
	}
	return ret_sc;
}

static ScreenID_t save_data(void)
{
	app_save_config();
	draw_title(eCH_CHSelect);
	return eMAX_SCREEN_ID;	
}

static void run_remote_mode(void)
{
	BackEnd_Cmd_t cmd;

	if(m_cfg.remote_mode == eREMOTE_ETHER){
		cmd = eCMD_RemoteEth;
	}else if(m_cfg.remote_mode == eREMOTE_RS232){
		cmd = eCMD_RemoteSerial;
	}

	send_cmd_2_backend(cmd, 0);
}

ScreenID_t blink_text_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = param.sc_id;
	uint8_t old_value = m_app_config->edge[m_cfg.cur_ch];
	
	if(ret_sc == eSET_TRIGGER_SC){
		old_value = m_app_config->edge[m_cfg.cur_ch];
	}else{
		old_value = m_app_config->mode;
	}
	switch(param.key){
		case eKey_Up:
		case eKey_Down:
			if(ret_sc == eSET_TRIGGER_SC){
				sprintf(m_cfg.blink_text[0], "Value : %s \n", old_value?"Falling":"Rising");
				m_app_config->mode = (old_value)?eFALLING:eRISING;
			}else{
				sprintf(m_cfg.blink_text[0], "      %s     \n", (old_value)?"1 : 1" : "1 : N");
				m_app_config->mode = (old_value)?eONE_ONE:eONE_N;
			}
			break;			
		case eKey_Enter:
			m_cfg.enable_blink = 0;
			ret_sc = save_data();
			break;
		case eKey_SetMode:
			if(ret_sc == eSET_TRIGGER_SC){
				sprintf(m_cfg.blink_text[0], "Value : %s \n", (old_value)?"Rising":"Falling");
				sprintf(m_cfg.blink_text[1], "Value :         \n");
			}else{
				sprintf(m_cfg.blink_text[0], "      %s     \n", (old_value)?"1 : N" : "1 : 1");
				sprintf(m_cfg.blink_text[1], "                \n");
				draw_title(eSET_OPMODE);
			}
			m_cfg.blink = 0;
			m_cfg.enable_blink = 1;
			break;
		case eKey_Mode:
			if(ret_sc == eSET_TRIGGER_SC){
				draw_title(eCH_TriggerSet);
			}else if(ret_sc == eOPMODE_SC){
				draw_title(eSEL_OPMODE);
			}
			break;
		default:
			break;
	}	
	
	return ret_sc;
}

ScreenID_t uart_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = param.sc_id;
	uint8_t old_value = m_app_config->dev_id;

	switch(param.key){
		case eKey_Up:
			if(m_app_config->dev_id++ > MAX_DEV_ID){
				m_app_config->dev_id = 1;
			}			
			break;
		case eKey_Down:
			if(m_app_config->dev_id-- <= 1){
				m_app_config->dev_id = MAX_DEV_ID;
			}			
			break;
		case eKey_Enter:
			if(m_cfg.set_mode){
				LCD_DISP_ON();	// Cursor off
				ret_sc = save_data();
				m_cfg.set_mode = 0;
			}else{
				m_cfg.remote_mode = eREMOTE_RS232;
				ret_sc = eREMOTE_SC;
				run_remote_mode();
			}
			break;			
		case eKey_SetMode:
			m_cfg.set_mode = 1;
			m_cfg.cursor = 14;
			draw_title(eRS_DevID);
			LCD_LOCATE(2, m_cfg.cursor);
			LCD_DISP_CURSOR();  // Cursor on		
			break;
		case eKey_Mode:
			draw_title(eRS_DevID);
			break;
		default:
			break;
	}
	if(old_value != m_app_config->dev_id){
		draw_title(eRS_DevID);
	}
	return ret_sc;
}

static void check_octet(uint8_t *check_value, uint8_t isUp)
{
	uint16_t addr = combine_array((int8_t *)check_value);
	uint8_t cur_digit = m_cfg.ip_digit;

	LOG_DBG("isup[%d] Addr[%x] cur_dig[%d]", isUp, addr, cur_digit);

	if(addr > 255){
		if(cur_digit == 0){
			check_value[0] = 0;
		}else{
			if(isUp){
				check_value[cur_digit] = 0;
			}else{ // 29x or 259
				check_value[cur_digit] = 5;
			}
		}
	}	
}

ScreenID_t ip_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = param.sc_id;	
	uint8_t temp_addr[3];
	char line_buf[LCD_PRINT_MAX];
	int i;
	uint8_t is_up = 0;
	uint8_t old_cursor = m_cfg.cursor;
	
	switch(param.key){
		case eKey_Up:
		case eKey_Down:
			memcpy(temp_addr, m_cfg.ipaddr[m_cfg.ip_idx],3);
			if(param.key == eKey_Up){
				temp_addr[m_cfg.ip_digit]++;
				is_up = 1;
			}else{
				if(temp_addr[m_cfg.ip_digit] == 0){
					temp_addr[m_cfg.ip_digit] = 9;
				}else{
					temp_addr[m_cfg.ip_digit]--;
				}
			}
			check_octet(temp_addr, is_up);
			memcpy(m_cfg.ipaddr[m_cfg.ip_idx], temp_addr, 3);
			sprintf(line_buf, "%03d.%03d.%03d.%03d ",	(uint8_t)combine_array(m_cfg.ipaddr[0]),
														(uint8_t)combine_array(m_cfg.ipaddr[1]),
														(uint8_t)combine_array(m_cfg.ipaddr[2]),
														(uint8_t)combine_array(m_cfg.ipaddr[3]));
			LCD_LOCATE(2,1);
			LCD_printstring(line_buf);
			break;
		case eKey_CursorUp:
			if(m_cfg.cursor--<=0){
				m_cfg.cursor = 15;
				m_cfg.ip_idx = 3;
				m_cfg.ip_digit=2;
			}
			m_cfg.ip_digit--;
			if(m_cfg.cursor%4 == 0){
				m_cfg.cursor--;
				m_cfg.ip_idx--;
				m_cfg.ip_digit=2;
			}
			break;
		case eKey_CursorDown:
			if(m_cfg.cursor++>=15){
				m_cfg.cursor = 1;
				m_cfg.ip_idx = 0;
				m_cfg.ip_digit =0;
			}
			m_cfg.ip_digit++;
			if(m_cfg.cursor%4 == 0){
				m_cfg.cursor++;
				m_cfg.ip_idx++;
				m_cfg.ip_digit = 0;
			}
			break;
		case eKey_Enter:
			if(m_cfg.set_mode){
				LCD_DISP_ON();	// Cursor off
				for(i = 0; i < 4; i++){
					m_app_config->ether.ipaddr[i] = combine_array(m_cfg.ipaddr[i]);
				}
				ret_sc = save_data();
				m_cfg.set_mode = 0;
			}else{
				//push_event0(EVT_Remote_Ether);
				m_cfg.remote_mode = eREMOTE_ETHER;
				ret_sc = eREMOTE_SC;
				run_remote_mode();
			}
			break;			
		case eKey_SetMode:
			m_cfg.digit_num = 2;
			for(i = 0; i < 4; i++){
				split_num(m_app_config->ether.ipaddr[i], m_cfg.ipaddr[i]);
			}
			m_cfg.cursor = 15;
			m_cfg.ip_idx = 3;
			m_cfg.ip_digit = 2;
			m_cfg.set_mode = 1;
			LCD_LOCATE(2, m_cfg.cursor);
			LCD_DISP_CURSOR();  // Cursor on		
			draw_title(eIP_Set);			
			break;
		case eKey_Mode:
			draw_title(eIP_Set);
			break;
		default:
			break;
	}

	if(m_cfg.cursor != old_cursor){
		LCD_LOCATE(2, m_cfg.cursor);
	}
	return ret_sc;
}
ScreenID_t port_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = eMAX_SCREEN_ID;
	uint8_t old_cursor = m_cfg.cursor;
	uint8_t temp_port[5];
	char line_buf[LCD_PRINT_MAX];
	
	switch(param.key){
		case eKey_Up:
		case eKey_Down:
			memcpy(temp_port, m_cfg.port,5);
			if(param.key == eKey_Up){
				if(temp_port[m_cfg.ip_digit] == 9){
					temp_port[m_cfg.ip_digit] = 0;
				}else{
					temp_port[m_cfg.ip_digit]++;
				}
			}else{
				if(temp_port[m_cfg.ip_digit] == 0){
					temp_port[m_cfg.ip_digit] = 9;
				}else{
					temp_port[m_cfg.ip_digit]--;
				}
			}
			memcpy(m_cfg.port, temp_port, 5);
			sprintf(line_buf, "Port : %05d    ", combine_array(m_cfg.port));
			LCD_LOCATE(2,1);
			LCD_printstring(line_buf);
			LCD_LOCATE(2,m_cfg.cursor);
			break;
		case eKey_CursorUp:
			if(m_cfg.cursor--<=7){
				m_cfg.cursor = 11;
				m_cfg.ip_digit=4;
			}else{
				m_cfg.ip_digit--;
			}
			break;
		case eKey_CursorDown:
			if(m_cfg.cursor++>=11){
				m_cfg.cursor = 7;
				m_cfg.ip_digit =0;
			}else{
				m_cfg.ip_digit++;
			}
			break;
		case eKey_Enter:
			if(m_cfg.set_mode){
				LCD_DISP_ON();	// Cursor off
				m_app_config->ether.port = combine_array(m_cfg.port);
				ret_sc = save_data();
				m_cfg.set_mode = 0;
			}else{
				m_cfg.remote_mode = eREMOTE_ETHER;
				ret_sc = eREMOTE_SC;
				run_remote_mode();
			}
			break;
		case eKey_SetMode:
			m_cfg.set_mode = 1;
			m_cfg.cursor = 11;
			m_cfg.digit_num = 5;
			m_cfg.ip_digit = 4;
			split_num(m_app_config->ether.port, m_cfg.port);
			LCD_LOCATE(2, m_cfg.cursor);
			LCD_DISP_CURSOR();  // Cursor on		
			draw_title(ePORT_Set);					
			break;
		case eKey_Mode:
			draw_title(ePORT_Set);
			break;
	}
	
	if(m_cfg.cursor != old_cursor){
		LCD_LOCATE(2, m_cfg.cursor);
	}	
	return ret_sc;
}

ScreenID_t self_test_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = eMAX_SCREEN_ID;

	switch(param.key){
		case eKey_Mode:
			draw_title(eSelf_Test);
			break;
		case eKey_Enter:
			send_cmd_2_backend(eCMD_SelfTest, 0);
			break;
	}
	return ret_sc;
}

ScreenID_t remote_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = eMAX_SCREEN_ID;

	switch(param.key){
		case eKey_ExitRemote:
			send_cmd_2_backend(eCMD_CloseRemote, 0);
			ret_sc = eCHANNEL_SC;
			break;
		case eKey_Mode:
			draw_title(eRemote_Mode);
			break;
	}
	
	return ret_sc;
}

static int findCharIndex(char c) {
    for (int i = 0; i < CHARSET_LENGTH; i++) {
        if (charSet[i] == c) return i;
    }
    return 0;
}

static void increaseChar(char *ch) {
    int idx = findCharIndex(*ch);

    *ch = charSet[(idx + 1) % CHARSET_LENGTH];
}

static void decreaseChar(char *ch) {
    int idx = findCharIndex(ch);
    *ch = charSet[(idx - 1 + CHARSET_LENGTH) % CHARSET_LENGTH];
}

ScreenID_t user_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = eMAX_SCREEN_ID;
	uint8_t old_cursor = m_cfg.cursor;
	char line_buf[LCD_PRINT_MAX];

	switch(param.key){
		case eKey_Up:
		case eKey_Down:
			if(eKey_Up){
				increaseChar(&m_cfg.model_name[m_cfg.cursor]);
			}else{
				decreaseChar(&m_cfg.model_name[m_cfg.cursor]);
			}
			sprintf(line_buf, "%s", m_cfg.model_name);
			LCD_LOCATE(1,1);
			LCD_printstring(line_buf);
			LCD_LOCATE(1,m_cfg.cursor);
			break;
		case eKey_CursorUp:
			m_cfg.cursor = (m_cfg.cursor - 1 + LINE_CHARACTER_MAX) % LINE_CHARACTER_MAX;
			break;
		case eKey_CursorDown:
			m_cfg.cursor = (m_cfg.cursor + 1 ) % LINE_CHARACTER_MAX;
			break;
		case eKey_Enter:
			LCD_DISP_ON();	// Cursor off
			memcpy(m_app_config->company, m_cfg.model_name, LINE_CHARACTER_MAX);
			ret_sc = save_data();
			m_cfg.set_mode = 0;
			break;
		case eKey_User:
			m_cfg.set_mode = 1;
			m_cfg.cursor = 2;
			LCD_LOCATE(1, m_cfg.cursor);
			LCD_DISP_CURSOR();  // Cursor on
			draw_title(eUSER_Mode);
			break;
	}
	if(m_cfg.cursor != old_cursor){
		LCD_LOCATE(1, m_cfg.cursor);
	}
	return ret_sc;
}

ScreenID_t factory_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = eMAX_SCREEN_ID;
	
	switch(param.key){
		case eKey_Enter:
			draw_title(eCH_CHSelect);
			break;
		case eKey_Factory:
			draw_title(eFactor_Mode);
			send_cmd_2_backend(eCMD_Factory, 0);
			break;
	}
	return ret_sc;
}

ScreenID_t select_ch_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = eMAX_SCREEN_ID;
	uint8_t ch_disp[4][LCD_PRINT_MAX] = {{"    CH2 CH4 CH6 \n"}, {"CH1     CH4 CH6 \n"},
										 {"CH1 CH2     CH6 \n"}, {"CH1 CH2 CH4     \n"}};

	switch(param.key){
		case eKey_Up:
		case eKey_Down:
		case eKey_Enter:
			break;
	}



	if(sel < 3){
		LCD_LOCATE(1,1);
		if(blink){
			LCD_printstring(ch_disp[sel]);
		}else{
			LCD_printstring("CH1 CH2     CH6 \n");
		}
	}else{
		LCD_LOCATE(2,1);
		if(blink){
			LCD_printstring("                \n");
		}else{
			LCD_printstring("CH8             \n");
		}
	}

	return ret_sc;
}

ScreenID_t version_screen_func(Screen_param_t param)
{
	ScreenID_t ret_sc = eMAX_SCREEN_ID;
	
	return ret_sc;
}
